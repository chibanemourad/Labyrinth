<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_20) on Wed Sep 15 13:15:11 CEST 2010 -->
<TITLE>
Toolkit
</TITLE>

<META NAME="date" CONTENT="2010-09-15">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Toolkit";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Toolkit.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/graphstream/algorithm/RandomWalk.TabuTimedEntity.html" title="class in org.graphstream.algorithm"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/graphstream/algorithm/Toolkit.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Toolkit.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.graphstream.algorithm</FONT>
<BR>
Class Toolkit</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.graphstream.algorithm.Toolkit</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Toolkit</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Lots of small often used algorithms on graphs.
 
 <p>
 Use this class with a static import. This should be a trait or a mixin in an
 advanced language.
 </p>
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#Toolkit()">Toolkit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#averageClusteringCoefficient(org.graphstream.graph.Graph)">averageClusteringCoefficient</A></B>(org.graphstream.graph.Graph&nbsp;graph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Average clustering coefficient of the whole graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#averageDegree(org.graphstream.graph.Graph)">averageDegree</A></B>(org.graphstream.graph.Graph&nbsp;graph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the value of the average degree of the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#clusteringCoefficient(org.graphstream.graph.Node)">clusteringCoefficient</A></B>(org.graphstream.graph.Node&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clustering coefficient for one node of the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#clusteringCoefficients(org.graphstream.graph.Graph)">clusteringCoefficients</A></B>(org.graphstream.graph.Graph&nbsp;graph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clustering coefficient for each node of the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.HashMap&lt;java.lang.Object,java.util.HashSet&lt;org.graphstream.graph.Node&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#communities(org.graphstream.graph.Graph, java.lang.String)">communities</A></B>(org.graphstream.graph.Graph&nbsp;graph,
            java.lang.String&nbsp;marker)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return set of nodes grouped by the value of one attribute (the marker).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#degreeAverageDeviation(org.graphstream.graph.Graph)">degreeAverageDeviation</A></B>(org.graphstream.graph.Graph&nbsp;graph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the value of the degree average deviation of the graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#degreeDistribution(org.graphstream.graph.Graph)">degreeDistribution</A></B>(org.graphstream.graph.Graph&nbsp;graph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the degree distribution of this graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.ArrayList&lt;org.graphstream.graph.Node&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#degreeMap(org.graphstream.graph.Graph)">degreeMap</A></B>(org.graphstream.graph.Graph&nbsp;graph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a list of nodes sorted by degree, the larger first.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#density(org.graphstream.graph.Graph)">density</A></B>(org.graphstream.graph.Graph&nbsp;graph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The density is the number of links in the graph divided by the total
 number of possible links.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#edgeLength(org.graphstream.graph.Edge)">edgeLength</A></B>(org.graphstream.graph.Edge&nbsp;edge)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../../org/graphstream/algorithm/Toolkit.html#edgeLength(org.graphstream.graph.Graph, java.lang.String)"><CODE>edgeLength(Graph,String)</CODE></A> but use an existing edge as
 argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#edgeLength(org.graphstream.graph.Graph, java.lang.String)">edgeLength</A></B>(org.graphstream.graph.Graph&nbsp;graph,
           java.lang.String&nbsp;id)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the edge length of the given edge according to its two nodes
 positions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#modularity(float[][])">modularity</A></B>(float[][]&nbsp;E)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the modularity of the graph from the E matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#modularity(org.graphstream.graph.Graph, java.lang.String)">modularity</A></B>(org.graphstream.graph.Graph&nbsp;graph,
           java.lang.String&nbsp;marker)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the modularity as defined by Newman and Girvan in "Finding and
 evaluating community structure in networks".</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#modularityMatrix(org.graphstream.graph.Graph, java.util.HashMap)">modularityMatrix</A></B>(org.graphstream.graph.Graph&nbsp;graph,
                 java.util.HashMap&lt;java.lang.Object,java.util.HashSet&lt;org.graphstream.graph.Node&gt;&gt;&nbsp;communities)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create the modularity matrix E from the communities.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#nodePosition(org.graphstream.graph.Graph, java.lang.String)">nodePosition</A></B>(org.graphstream.graph.Graph&nbsp;graph,
             java.lang.String&nbsp;id)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieve a node position from its attributes ("x", "y", "z", or "xy", or
 "xyz").</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#nodePosition(org.graphstream.graph.Graph, java.lang.String, float[])">nodePosition</A></B>(org.graphstream.graph.Graph&nbsp;graph,
             java.lang.String&nbsp;id,
             float[]&nbsp;xyz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../../org/graphstream/algorithm/Toolkit.html#nodePosition(org.graphstream.graph.Graph, java.lang.String)"><CODE>nodePosition(Graph,String)</CODE></A>, but instead of returning a
 newly allocated array, fill up the array given as parameter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#nodePosition(org.graphstream.graph.Node)">nodePosition</A></B>(org.graphstream.graph.Node&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../../org/graphstream/algorithm/Toolkit.html#nodePosition(org.graphstream.graph.Graph, java.lang.String)"><CODE>nodePosition(Graph,String)</CODE></A> but use an existing node as
 argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#nodePosition(org.graphstream.graph.Node, float[])">nodePosition</A></B>(org.graphstream.graph.Node&nbsp;node,
             float[]&nbsp;xyz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../../org/graphstream/algorithm/Toolkit.html#nodePosition(org.graphstream.graph.Graph, java.lang.String, float[])"><CODE>nodePosition(Graph,String,float[])</CODE></A> but use an existing node
 as argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.graphstream.graph.Edge</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#randomEdge(org.graphstream.graph.Graph)">randomEdge</A></B>(org.graphstream.graph.Graph&nbsp;graph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choose an edge at random.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.graphstream.graph.Edge</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#randomEdge(org.graphstream.graph.Graph, java.util.Random)">randomEdge</A></B>(org.graphstream.graph.Graph&nbsp;graph,
           java.util.Random&nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choose an edge at random.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.graphstream.graph.Edge</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#randomEdge(org.graphstream.graph.Node)">randomEdge</A></B>(org.graphstream.graph.Node&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choose an edge at random from the edges connected to the given node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.graphstream.graph.Edge</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#randomEdge(org.graphstream.graph.Node, java.util.Random)">randomEdge</A></B>(org.graphstream.graph.Node&nbsp;node,
           java.util.Random&nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choose an edge at random from the edges connected to the given node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.graphstream.graph.Edge</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#randomInEdge(org.graphstream.graph.Node)">randomInEdge</A></B>(org.graphstream.graph.Node&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choose an edge at random from the entering edges connected to the given
 node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.graphstream.graph.Edge</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#randomInEdge(org.graphstream.graph.Node, java.util.Random)">randomInEdge</A></B>(org.graphstream.graph.Node&nbsp;node,
             java.util.Random&nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choose an edge at random from the entering edges connected to the given
 node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.graphstream.graph.Node</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#randomNode(org.graphstream.graph.Graph)">randomNode</A></B>(org.graphstream.graph.Graph&nbsp;graph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choose a node at random.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.graphstream.graph.Node</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#randomNode(org.graphstream.graph.Graph, java.util.Random)">randomNode</A></B>(org.graphstream.graph.Graph&nbsp;graph,
           java.util.Random&nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choose a node at random.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.graphstream.graph.Edge</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#randomOutEdge(org.graphstream.graph.Node)">randomOutEdge</A></B>(org.graphstream.graph.Node&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choose an edge at random from the leaving edges connected to the given
 node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;org.graphstream.graph.Edge</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/graphstream/algorithm/Toolkit.html#randomOutEdge(org.graphstream.graph.Node, java.util.Random)">randomOutEdge</A></B>(org.graphstream.graph.Node&nbsp;node,
              java.util.Random&nbsp;random)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Choose an edge at random from the leaving edges connected to the given
 node.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Toolkit()"><!-- --></A><H3>
Toolkit</H3>
<PRE>
public <B>Toolkit</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="degreeDistribution(org.graphstream.graph.Graph)"><!-- --></A><H3>
degreeDistribution</H3>
<PRE>
public static int[] <B>degreeDistribution</B>(org.graphstream.graph.Graph&nbsp;graph)</PRE>
<DL>
<DD>Compute the degree distribution of this graph. Each cell of the returned
 array contains the number of nodes having degree n where n is the index
 of the cell. For example cell 0 counts how many nodes have zero edges,
 cell 5 counts how many nodes have five edges. The last index indicates
 the maximum degree.
<P>
<DD><DL>
<DT><B>Complexity:</B></DT>
  <DD>O(n) where n is the number of nodes.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="degreeMap(org.graphstream.graph.Graph)"><!-- --></A><H3>
degreeMap</H3>
<PRE>
public static java.util.ArrayList&lt;org.graphstream.graph.Node&gt; <B>degreeMap</B>(org.graphstream.graph.Graph&nbsp;graph)</PRE>
<DL>
<DD>Return a list of nodes sorted by degree, the larger first.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The degree map.<DT><B>Complexity:</B></DT>
  <DD>O(n log(n)) where n is the number of nodes.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="averageDegree(org.graphstream.graph.Graph)"><!-- --></A><H3>
averageDegree</H3>
<PRE>
public static float <B>averageDegree</B>(org.graphstream.graph.Graph&nbsp;graph)</PRE>
<DL>
<DD>Returns the value of the average degree of the graph. A node with a loop
 edge has degree two.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The average degree of the graph.<DT><B>Complexity:</B></DT>
  <DD>O(1).</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="density(org.graphstream.graph.Graph)"><!-- --></A><H3>
density</H3>
<PRE>
public static float <B>density</B>(org.graphstream.graph.Graph&nbsp;graph)</PRE>
<DL>
<DD>The density is the number of links in the graph divided by the total
 number of possible links.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The density of the graph.<DT><B>Complexity:</B></DT>
  <DD>O(1)</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="degreeAverageDeviation(org.graphstream.graph.Graph)"><!-- --></A><H3>
degreeAverageDeviation</H3>
<PRE>
public static float <B>degreeAverageDeviation</B>(org.graphstream.graph.Graph&nbsp;graph)</PRE>
<DL>
<DD>Returns the value of the degree average deviation of the graph.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The degree average deviation.<DT><B>Complexity:</B></DT>
  <DD>O(n) where n is the number of nodes.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="clusteringCoefficients(org.graphstream.graph.Graph)"><!-- --></A><H3>
clusteringCoefficients</H3>
<PRE>
public static double[] <B>clusteringCoefficients</B>(org.graphstream.graph.Graph&nbsp;graph)</PRE>
<DL>
<DD>Clustering coefficient for each node of the graph.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>An array whose size correspond to the number of nodes, where each
         element is the clustering coefficient of a node.<DT><B>Complexity:</B></DT>
  <DD>at worse O(n d^2) where n is the number of nodes and d the
             average or maximum degree of nodes.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="averageClusteringCoefficient(org.graphstream.graph.Graph)"><!-- --></A><H3>
averageClusteringCoefficient</H3>
<PRE>
public static double <B>averageClusteringCoefficient</B>(org.graphstream.graph.Graph&nbsp;graph)</PRE>
<DL>
<DD>Average clustering coefficient of the whole graph. Average of each node
 individual clustering coefficient.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The average clustering coefficient.<DT><B>Complexity:</B></DT>
  <DD>at worse O(n d^2) where n is the number of nodes and d the
             average or maximum degree of nodes.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="clusteringCoefficient(org.graphstream.graph.Node)"><!-- --></A><H3>
clusteringCoefficient</H3>
<PRE>
public static double <B>clusteringCoefficient</B>(org.graphstream.graph.Node&nbsp;node)</PRE>
<DL>
<DD>Clustering coefficient for one node of the graph.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>node</CODE> - The node to compute the clustering coefficient for.
<DT><B>Returns:</B><DD>The clustering coefficient for this node.<DT><B>Complexity:</B></DT>
  <DD>O(d^2) where d is the degree of the given node.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="randomNode(org.graphstream.graph.Graph)"><!-- --></A><H3>
randomNode</H3>
<PRE>
public static org.graphstream.graph.Node <B>randomNode</B>(org.graphstream.graph.Graph&nbsp;graph)</PRE>
<DL>
<DD>Choose a node at random.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>A node chosen at random, null if the graph is empty.<DT><B>Complexity:</B></DT>
  <DD>at worse O(n) where n is the number of nodes.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="randomNode(org.graphstream.graph.Graph, java.util.Random)"><!-- --></A><H3>
randomNode</H3>
<PRE>
public static org.graphstream.graph.Node <B>randomNode</B>(org.graphstream.graph.Graph&nbsp;graph,
                                                    java.util.Random&nbsp;random)</PRE>
<DL>
<DD>Choose a node at random.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>random</CODE> - The random number generator to use.
<DT><B>Returns:</B><DD>A node chosen at random, null if the graph is empty.<DT><B>Complexity:</B></DT>
  <DD>at worse O(n) where n is the number of nodes.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="randomEdge(org.graphstream.graph.Graph)"><!-- --></A><H3>
randomEdge</H3>
<PRE>
public static org.graphstream.graph.Edge <B>randomEdge</B>(org.graphstream.graph.Graph&nbsp;graph)</PRE>
<DL>
<DD>Choose an edge at random.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>An edge chosen at random. complexity at worse O(n) where n is the
         number of edges.</DL>
</DD>
</DL>
<HR>

<A NAME="randomEdge(org.graphstream.graph.Graph, java.util.Random)"><!-- --></A><H3>
randomEdge</H3>
<PRE>
public static org.graphstream.graph.Edge <B>randomEdge</B>(org.graphstream.graph.Graph&nbsp;graph,
                                                    java.util.Random&nbsp;random)</PRE>
<DL>
<DD>Choose an edge at random.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>random</CODE> - The random number generator to use.
<DT><B>Returns:</B><DD>An edge chosen at random, null if the graph has no edges.
         complexity at worse O(n) where n is the number of edges.</DL>
</DD>
</DL>
<HR>

<A NAME="randomEdge(org.graphstream.graph.Node)"><!-- --></A><H3>
randomEdge</H3>
<PRE>
public static org.graphstream.graph.Edge <B>randomEdge</B>(org.graphstream.graph.Node&nbsp;node)</PRE>
<DL>
<DD>Choose an edge at random from the edges connected to the given node.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>An edge chosen at random, null if the node has no edges.
         complexity at worse O(n) where n is the number of edges.</DL>
</DD>
</DL>
<HR>

<A NAME="randomInEdge(org.graphstream.graph.Node)"><!-- --></A><H3>
randomInEdge</H3>
<PRE>
public static org.graphstream.graph.Edge <B>randomInEdge</B>(org.graphstream.graph.Node&nbsp;node)</PRE>
<DL>
<DD>Choose an edge at random from the entering edges connected to the given
 node.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>An edge chosen at random, null if the node has no entering edges.
         complexity at worse O(n) where n is the number of edges.</DL>
</DD>
</DL>
<HR>

<A NAME="randomOutEdge(org.graphstream.graph.Node)"><!-- --></A><H3>
randomOutEdge</H3>
<PRE>
public static org.graphstream.graph.Edge <B>randomOutEdge</B>(org.graphstream.graph.Node&nbsp;node)</PRE>
<DL>
<DD>Choose an edge at random from the leaving edges connected to the given
 node.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>An edge chosen at random, null if the node has no leaving edges.
         complexity at worse O(n) where n is the number of edges.</DL>
</DD>
</DL>
<HR>

<A NAME="randomEdge(org.graphstream.graph.Node, java.util.Random)"><!-- --></A><H3>
randomEdge</H3>
<PRE>
public static org.graphstream.graph.Edge <B>randomEdge</B>(org.graphstream.graph.Node&nbsp;node,
                                                    java.util.Random&nbsp;random)</PRE>
<DL>
<DD>Choose an edge at random from the edges connected to the given node.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>random</CODE> - The random number generator to use.
<DT><B>Returns:</B><DD>An edge chosen at random, null if the node has no edges.
         complexity at worse O(n) where n is the number of edges.</DL>
</DD>
</DL>
<HR>

<A NAME="randomInEdge(org.graphstream.graph.Node, java.util.Random)"><!-- --></A><H3>
randomInEdge</H3>
<PRE>
public static org.graphstream.graph.Edge <B>randomInEdge</B>(org.graphstream.graph.Node&nbsp;node,
                                                      java.util.Random&nbsp;random)</PRE>
<DL>
<DD>Choose an edge at random from the entering edges connected to the given
 node.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>random</CODE> - The random number generator to use.
<DT><B>Returns:</B><DD>An edge chosen at random, null if the node has no entering edges.
         complexity at worse O(n) where n is the number of edges.</DL>
</DD>
</DL>
<HR>

<A NAME="randomOutEdge(org.graphstream.graph.Node, java.util.Random)"><!-- --></A><H3>
randomOutEdge</H3>
<PRE>
public static org.graphstream.graph.Edge <B>randomOutEdge</B>(org.graphstream.graph.Node&nbsp;node,
                                                       java.util.Random&nbsp;random)</PRE>
<DL>
<DD>Choose an edge at random from the leaving edges connected to the given
 node.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>random</CODE> - The random number generator to use.
<DT><B>Returns:</B><DD>An edge chosen at random, null if the node has no leaving edges.
         complexity at worse O(n) where n is the number of edges.</DL>
</DD>
</DL>
<HR>

<A NAME="communities(org.graphstream.graph.Graph, java.lang.String)"><!-- --></A><H3>
communities</H3>
<PRE>
public static java.util.HashMap&lt;java.lang.Object,java.util.HashSet&lt;org.graphstream.graph.Node&gt;&gt; <B>communities</B>(org.graphstream.graph.Graph&nbsp;graph,
                                                                                                            java.lang.String&nbsp;marker)</PRE>
<DL>
<DD>Return set of nodes grouped by the value of one attribute (the marker).
 For example, if the marker is "color" and in the graph there are nodes
 whose "color" attribute value is "red" and others with value "blue", this
 method will return two sets, one containing all nodes corresponding to
 the nodes whose "color" attribute is red, the other with blue nodes. If
 some nodes do not have the "color" attribute, a third set is returned.
 The returned sets are stored in a hash map whose keys are the values of
 the marker attribute (in our example, the keys would be "red" and "blue",
 and if there are nodes that do not have the "color" attribute, the third
 set will have key "NULL_COMMUNITY").
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>marker</CODE> - The attribute that allows to group nodes.
<DT><B>Returns:</B><DD>The communities indexed by the value of the marker.<DT><B>Complexity:</B></DT>
  <DD>O(n) with n the number of nodes.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="modularityMatrix(org.graphstream.graph.Graph, java.util.HashMap)"><!-- --></A><H3>
modularityMatrix</H3>
<PRE>
public static float[][] <B>modularityMatrix</B>(org.graphstream.graph.Graph&nbsp;graph,
                                         java.util.HashMap&lt;java.lang.Object,java.util.HashSet&lt;org.graphstream.graph.Node&gt;&gt;&nbsp;communities)</PRE>
<DL>
<DD>Create the modularity matrix E from the communities. The given
 communities are set of nodes forming the communities as produced by the
 <A HREF="../../../org/graphstream/algorithm/Toolkit.html#communities(org.graphstream.graph.Graph, java.lang.String)"><CODE>communities(Graph,String)</CODE></A> method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>communities</CODE> - Set of nodes.
<DT><B>Returns:</B><DD>The E matrix as defined by Newman and Girvan.<DT><B>Complexity:</B></DT>
  <DD>O(m!k) with m the number of communities and k the average
             number of nodes per community.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="modularity(float[][])"><!-- --></A><H3>
modularity</H3>
<PRE>
public static float <B>modularity</B>(float[][]&nbsp;E)</PRE>
<DL>
<DD>Compute the modularity of the graph from the E matrix.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>E</CODE> - The E matrix given by <A HREF="../../../org/graphstream/algorithm/Toolkit.html#modularityMatrix(org.graphstream.graph.Graph, java.util.HashMap)"><CODE>modularityMatrix(Graph,HashMap)</CODE></A>
            .
<DT><B>Returns:</B><DD>The modularity of the graph.<DT><B>Complexity:</B></DT>
  <DD>O(m!) with m the number of communities.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="modularity(org.graphstream.graph.Graph, java.lang.String)"><!-- --></A><H3>
modularity</H3>
<PRE>
public static float <B>modularity</B>(org.graphstream.graph.Graph&nbsp;graph,
                               java.lang.String&nbsp;marker)</PRE>
<DL>
<DD>Computes the modularity as defined by Newman and Girvan in "Finding and
 evaluating community structure in networks". This algorithm traverses the
 graph to count nodes in communities. For this to work, there must exist
 an attribute on each node whose value define the community the node
 pertains to (see <A HREF="../../../org/graphstream/algorithm/Toolkit.html#communities(org.graphstream.graph.Graph, java.lang.String)"><CODE>communities(Graph,String)</CODE></A>).
 
 This method is an utility method that call:
 <ul>
 <li><A HREF="../../../org/graphstream/algorithm/Toolkit.html#communities(org.graphstream.graph.Graph, java.lang.String)"><CODE>communities(Graph,String)</CODE></A></li>
 <li><A HREF="../../../org/graphstream/algorithm/Toolkit.html#modularityMatrix(org.graphstream.graph.Graph, java.util.HashMap)"><CODE>modularityMatrix(Graph,HashMap)</CODE></A></li>
 <li><A HREF="../../../org/graphstream/algorithm/Toolkit.html#modularity(float[][])"><CODE>modularity(float[][])</CODE></A></li>
 </ul>
 in order to produce the modularity value.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>marker</CODE> - The community attribute stored on nodes.
<DT><B>Returns:</B><DD>The graph modularity.<DT><B>See Also:</B><DD><A HREF="../../../org/graphstream/algorithm/measure/Modularity.html" title="class in org.graphstream.algorithm.measure"><CODE>Modularity</CODE></A><DT><B>Complexity:</B></DT>
  <DD>0(n + m! + m!k) with n the number of nodes, m the number of
             communities and k the average number of nodes per
             communities.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="nodePosition(org.graphstream.graph.Graph, java.lang.String)"><!-- --></A><H3>
nodePosition</H3>
<PRE>
public static float[] <B>nodePosition</B>(org.graphstream.graph.Graph&nbsp;graph,
                                   java.lang.String&nbsp;id)</PRE>
<DL>
<DD>Retrieve a node position from its attributes ("x", "y", "z", or "xy", or
 "xyz").
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>id</CODE> - The node identifier.
<DT><B>Returns:</B><DD>A newly allocated array of three floats containing the (x,y,z)
         position of the node, or null if the node is not part of the
         graph.</DL>
</DD>
</DL>
<HR>

<A NAME="nodePosition(org.graphstream.graph.Node)"><!-- --></A><H3>
nodePosition</H3>
<PRE>
public static float[] <B>nodePosition</B>(org.graphstream.graph.Node&nbsp;node)</PRE>
<DL>
<DD>Like <A HREF="../../../org/graphstream/algorithm/Toolkit.html#nodePosition(org.graphstream.graph.Graph, java.lang.String)"><CODE>nodePosition(Graph,String)</CODE></A> but use an existing node as
 argument.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>node</CODE> - The node to consider.
<DT><B>Returns:</B><DD>A newly allocated array of three floats containing the (x,y,z)
         position of the node.</DL>
</DD>
</DL>
<HR>

<A NAME="nodePosition(org.graphstream.graph.Graph, java.lang.String, float[])"><!-- --></A><H3>
nodePosition</H3>
<PRE>
public static void <B>nodePosition</B>(org.graphstream.graph.Graph&nbsp;graph,
                                java.lang.String&nbsp;id,
                                float[]&nbsp;xyz)</PRE>
<DL>
<DD>Like <A HREF="../../../org/graphstream/algorithm/Toolkit.html#nodePosition(org.graphstream.graph.Graph, java.lang.String)"><CODE>nodePosition(Graph,String)</CODE></A>, but instead of returning a
 newly allocated array, fill up the array given as parameter. This array
 must have at least three cells.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>id</CODE> - The node identifier.<DD><CODE>xyz</CODE> - An array of at least three cells.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - If the node with the given identifier does not exist.</DL>
</DD>
</DL>
<HR>

<A NAME="nodePosition(org.graphstream.graph.Node, float[])"><!-- --></A><H3>
nodePosition</H3>
<PRE>
public static void <B>nodePosition</B>(org.graphstream.graph.Node&nbsp;node,
                                float[]&nbsp;xyz)</PRE>
<DL>
<DD>Like <A HREF="../../../org/graphstream/algorithm/Toolkit.html#nodePosition(org.graphstream.graph.Graph, java.lang.String, float[])"><CODE>nodePosition(Graph,String,float[])</CODE></A> but use an existing node
 as argument.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>node</CODE> - The node to consider.<DD><CODE>xyz</CODE> - An array of at least three cells.</DL>
</DD>
</DL>
<HR>

<A NAME="edgeLength(org.graphstream.graph.Graph, java.lang.String)"><!-- --></A><H3>
edgeLength</H3>
<PRE>
public static float <B>edgeLength</B>(org.graphstream.graph.Graph&nbsp;graph,
                               java.lang.String&nbsp;id)</PRE>
<DL>
<DD>Compute the edge length of the given edge according to its two nodes
 positions.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>id</CODE> - The identifier of the edge.
<DT><B>Returns:</B><DD>The edge length or -1 if the nodes of the edge have no positions.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - If the edge cannot be found.</DL>
</DD>
</DL>
<HR>

<A NAME="edgeLength(org.graphstream.graph.Edge)"><!-- --></A><H3>
edgeLength</H3>
<PRE>
public static float <B>edgeLength</B>(org.graphstream.graph.Edge&nbsp;edge)</PRE>
<DL>
<DD>Like <A HREF="../../../org/graphstream/algorithm/Toolkit.html#edgeLength(org.graphstream.graph.Graph, java.lang.String)"><CODE>edgeLength(Graph,String)</CODE></A> but use an existing edge as
 argument.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>edge</CODE> - 
<DT><B>Returns:</B><DD>The edge length or -1 if the nodes of the edge have no positions.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Toolkit.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/graphstream/algorithm/RandomWalk.TabuTimedEntity.html" title="class in org.graphstream.algorithm"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/graphstream/algorithm/Toolkit.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Toolkit.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
